{
  "version": 3,
  "file": "stampsdk.js",
  "sources": [
    "lib/util.js",
    "lib/oauth.js",
    "lib/handjs-1.8.3.js",
    "stampsdk.js"
  ],
  "names": [],
  "mappings": "AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3RA,AD4RA;AC3RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvTA,ADwTA;ACvTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7uBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "sourcesContent": [
    "define('lib/util',[],function() {\n// private property\n  var base64 = {};\n  base64._keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n\n  function browserSupportsCSSProperty(propertyName) {\n    var elm = document.createElement('div');\n    propertyName = propertyName.toLowerCase();\n\n    if (elm.style[propertyName] != undefined)\n      return true;\n\n    var propertyNameCapital = propertyName.charAt(0).toUpperCase() + propertyName.substr(1),\n      domPrefixes = 'Webkit Moz ms O'.split(' ');\n\n    for (var i = 0; i < domPrefixes.length; i++) {\n      if (elm.style[domPrefixes[i] + propertyNameCapital] != undefined)\n        return true;\n    }\n\n    return false;\n  }\n\n  // private method for UTF-8 encoding\n  base64._utf8_encode = function (string) {\n      string = string.replace(/\\r\\n/g,\"\\n\");\n      var utftext = \"\";\n      for (var n = 0; n < string.length; n++) {\n          var c = string.charCodeAt(n);\n          if (c < 128) {\n              utftext += String.fromCharCode(c);\n          }\n          else if((c > 127) && (c < 2048)) {\n              utftext += String.fromCharCode((c >> 6) | 192);\n              utftext += String.fromCharCode((c & 63) | 128);\n          }\n          else {\n              utftext += String.fromCharCode((c >> 12) | 224);\n              utftext += String.fromCharCode(((c >> 6) & 63) | 128);\n              utftext += String.fromCharCode((c & 63) | 128);\n          }\n      }\n      return utftext;\n  };\n\n  // private method for UTF-8 decoding\n  base64._utf8_decode = function (utftext) {\n    var string = \"\";\n    var i = 0;\n    var c = c1 = c2 = 0;\n    \n    while ( i < utftext.length ) {\n      c = utftext.charCodeAt(i);\n      if (c < 128) {\n        string += String.fromCharCode(c);\n        i++;\n      }\n      else if((c > 191) && (c < 224)) {\n        c2 = utftext.charCodeAt(i+1);\n        string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));\n        i += 2;\n      }\n      else {\n        c2 = utftext.charCodeAt(i+1);\n        c3 = utftext.charCodeAt(i+2);\n        string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));\n        i += 3;\n      }\n    }\n    return string;\n  };\n\n  // public method for encoding\n  base64.encode = function (input) {\n      var output = \"\";\n      var chr1, chr2, chr3, enc1, enc2, enc3, enc4;\n      var i = 0;\n      input = base64._utf8_encode(input);\n      while (i < input.length) {\n          chr1 = input.charCodeAt(i++);\n          chr2 = input.charCodeAt(i++);\n          chr3 = input.charCodeAt(i++);\n          enc1 = chr1 >> 2;\n          enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n          enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\n          enc4 = chr3 & 63;\n          if (isNaN(chr2)) {\n              enc3 = enc4 = 64;\n          } else if (isNaN(chr3)) {\n              enc4 = 64;\n          }\n          output = output +\n              this._keyStr.charAt(enc1) + this._keyStr.charAt(enc2) +\n              this._keyStr.charAt(enc3) + this._keyStr.charAt(enc4);\n      }\n      return output;\n  };\n  \n  // public method for decoding\n  base64.decode = function (input) {\n    var output = \"\";\n    var chr1, chr2, chr3;\n    var enc1, enc2, enc3, enc4;\n    var i = 0;\n    input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n    while (i < input.length) {\n      enc1 = this._keyStr.indexOf(input.charAt(i++));\n      enc2 = this._keyStr.indexOf(input.charAt(i++));\n      enc3 = this._keyStr.indexOf(input.charAt(i++));\n      enc4 = this._keyStr.indexOf(input.charAt(i++));\n      chr1 = (enc1 << 2) | (enc2 >> 4);\n      chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);\n      chr3 = ((enc3 & 3) << 6) | enc4;\n      output = output + String.fromCharCode(chr1);\n      if (enc3 != 64) {\n        output = output + String.fromCharCode(chr2);\n      }\n      if (enc4 != 64) {\n        output = output + String.fromCharCode(chr3);\n      }\n    }\n    output = base64._utf8_decode(output);\n    return output;\n  };\n\n  /**\n  * simple class inheritance\n  * @param {Function} child\n  * @param {Function} base\n  * @param {Object} [properties]\n  */\n  function inherit(child, base, properties) {\n    var baseP = base.prototype,\n    childP;\n    childP = child.prototype = Object.create(baseP);\n    childP.constructor = child;\n    childP._super = baseP;\n    if (properties) {\n      extend(childP, properties);\n    }\n  }\n\n  /**\n  * extend object.\n  * means that properties in dest will be overwritten by the ones in src.\n  * @param {Object} dest\n  * @param {Object} src\n  * @param {Boolean} [merge]\n  * @returns {Object} dest\n  */\n  function extend(dest, src, merge) {\n    var keys = Object.keys(src);\n    for (var i = 0, len = keys.length; i < len; i++) {\n      if (!merge || (merge && dest[keys[i]] === undefined)) {\n        dest[keys[i]] = src[keys[i]];\n      }\n    }\n    return dest;\n  }\n\n  /**\n  * merge the values from src in the dest.\n  * means that properties that exist in dest will not be overwritten by src\n  * @param {Object} dest\n  * @param {Object} src\n  * @returns {Object} dest\n  */\n  function merge(dest, src) {\n    return extend(dest, src, true);\n  }\n\n  function prettyPrint(obj){\n    var toString = Object.prototype.toString,\n        newLine = \"<br>\", space = \"&nbsp;\", tab = 8,\n        buffer = \"\",\n        //Second argument is indent\n        indent = arguments[1] || 0,\n        //For better performance, Cache indentStr for a given indent.\n        indentStr = (function(n){\n          var str = \"\";\n          while(n--){\n            str += space;\n          }\n          return str;\n        })(indent);\n\n    if(!obj || ( typeof obj != \"object\" && typeof obj!= \"function\" )){\n      //any non-object ( Boolean, String, Number), null, undefined, NaN\n      buffer += obj;\n    }else if(toString.call(obj) == \"[object Date]\"){\n      buffer += \"[Date] \" + obj;\n    }else if(toString.call(obj) == \"[object RegExp\"){\n      buffer += \"[RegExp] \" + obj;\n    }else if(toString.call(obj) == \"[object Function]\"){\n      buffer += \"[Function] \" + obj;\n    }else if(toString.call(obj) == \"[object Array]\"){\n      var idx = 0, len = obj.length;\n      buffer += \"[\"+newLine;\n      while(idx < len){\n        buffer += [\n          indentStr, idx, \": \",\n          prettyPrint(obj[idx], indent + tab)\n        ].join(\"\");\n        buffer += \"<br>\";\n        idx++;\n      }\n      buffer += indentStr + \"]\";\n    }else { //Handle Object\n      var prop;\n      buffer += \"{\"+newLine;\n      for(prop in obj){\n        buffer += [\n          indentStr, prop, \": \",\n          prettyPrint(obj[prop], indent + tab)\n        ].join(\"\");\n        buffer += newLine;\n      }\n      buffer += indentStr + \"}\";\n    }\n\n    return buffer;\n  }\n\n  (function() {\n    var method;\n    var noop = function noop() {};\n    var methods = [\n      'assert', 'clear', 'count', 'debug', 'dir', 'dirxml', 'error',\n      'exception', 'group', 'groupCollapsed', 'groupEnd', 'info', 'log',\n      'markTimeline', 'profile', 'profileEnd', 'table', 'time', 'timeEnd',\n      'timeStamp', 'trace', 'warn'\n    ];\n    var length = methods.length;\n    var console = (window.console = window.console || {});\n\n    while (length--) {\n      method = methods[length];\n\n      // Only stub undefined methods.\n      if (!console[method]) {\n        console[method] = noop;\n      }\n    }\n  }());\n\n  \n  return {\n    base64: base64,\n    uuid: function() { \n      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n        var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);\n        return v.toString(16);\n      });\n    },\n    createCORSRequest: function(method, url) {\n      var xhr = new XMLHttpRequest();\n      if (\"withCredentials\" in xhr){\n          xhr.open(method, url, true);\n      } else if (typeof XDomainRequest != \"undefined\"){\n          xhr = new XDomainRequest();\n          xhr.open(method, url);\n      } else {\n          xhr = null;\n      }\n      return xhr;\n    },\n    getQueryParams: function() {\n      var params = window.location.href.split(\"?\")[1];\n      if(params === undefined ) return {};\n      params = params.split(\"&\");\n      params_map = {};\n      for(var i = 0; i < params.length; i++){\n        var param = params[i].split(\"=\");\n        params_map[param[0]] = param[1];\n      }\n      return params_map;\n    },\n    inherit: inherit,\n    extend:extend,\n    merge:merge,\n    pprint: prettyPrint\n  }\n});\n\n",
    "/*\nCryptoJS v3.1.2\ncode.google.com/p/crypto-js\n(c) 2009-2013 by Jeff Mott. All rights reserved.\ncode.google.com/p/crypto-js/wiki/License\n*/\nvar CryptoJS=CryptoJS||function(g,l){var e={},d=e.lib={},m=function(){},k=d.Base={extend:function(a){m.prototype=this;var c=new m;a&&c.mixIn(a);c.hasOwnProperty(\"init\")||(c.init=function(){c.$super.init.apply(this,arguments)});c.init.prototype=c;c.$super=this;return c},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var c in a)a.hasOwnProperty(c)&&(this[c]=a[c]);a.hasOwnProperty(\"toString\")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},\np=d.WordArray=k.extend({init:function(a,c){a=this.words=a||[];this.sigBytes=c!=l?c:4*a.length},toString:function(a){return(a||n).stringify(this)},concat:function(a){var c=this.words,q=a.words,f=this.sigBytes;a=a.sigBytes;this.clamp();if(f%4)for(var b=0;b<a;b++)c[f+b>>>2]|=(q[b>>>2]>>>24-8*(b%4)&255)<<24-8*((f+b)%4);else if(65535<q.length)for(b=0;b<a;b+=4)c[f+b>>>2]=q[b>>>2];else c.push.apply(c,q);this.sigBytes+=a;return this},clamp:function(){var a=this.words,c=this.sigBytes;a[c>>>2]&=4294967295<<\n32-8*(c%4);a.length=g.ceil(c/4)},clone:function(){var a=k.clone.call(this);a.words=this.words.slice(0);return a},random:function(a){for(var c=[],b=0;b<a;b+=4)c.push(4294967296*g.random()|0);return new p.init(c,a)}}),b=e.enc={},n=b.Hex={stringify:function(a){var c=a.words;a=a.sigBytes;for(var b=[],f=0;f<a;f++){var d=c[f>>>2]>>>24-8*(f%4)&255;b.push((d>>>4).toString(16));b.push((d&15).toString(16))}return b.join(\"\")},parse:function(a){for(var c=a.length,b=[],f=0;f<c;f+=2)b[f>>>3]|=parseInt(a.substr(f,\n2),16)<<24-4*(f%8);return new p.init(b,c/2)}},j=b.Latin1={stringify:function(a){var c=a.words;a=a.sigBytes;for(var b=[],f=0;f<a;f++)b.push(String.fromCharCode(c[f>>>2]>>>24-8*(f%4)&255));return b.join(\"\")},parse:function(a){for(var c=a.length,b=[],f=0;f<c;f++)b[f>>>2]|=(a.charCodeAt(f)&255)<<24-8*(f%4);return new p.init(b,c)}},h=b.Utf8={stringify:function(a){try{return decodeURIComponent(escape(j.stringify(a)))}catch(c){throw Error(\"Malformed UTF-8 data\");}},parse:function(a){return j.parse(unescape(encodeURIComponent(a)))}},\nr=d.BufferedBlockAlgorithm=k.extend({reset:function(){this._data=new p.init;this._nDataBytes=0},_append:function(a){\"string\"==typeof a&&(a=h.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(a){var c=this._data,b=c.words,f=c.sigBytes,d=this.blockSize,e=f/(4*d),e=a?g.ceil(e):g.max((e|0)-this._minBufferSize,0);a=e*d;f=g.min(4*a,f);if(a){for(var k=0;k<a;k+=d)this._doProcessBlock(b,k);k=b.splice(0,a);c.sigBytes-=f}return new p.init(k,f)},clone:function(){var a=k.clone.call(this);\na._data=this._data.clone();return a},_minBufferSize:0});d.Hasher=r.extend({cfg:k.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){r.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(b,d){return(new a.init(d)).finalize(b)}},_createHmacHelper:function(a){return function(b,d){return(new s.HMAC.init(a,\nd)).finalize(b)}}});var s=e.algo={};return e}(Math);\n(function(){var g=CryptoJS,l=g.lib,e=l.WordArray,d=l.Hasher,m=[],l=g.algo.SHA1=d.extend({_doReset:function(){this._hash=new e.init([1732584193,4023233417,2562383102,271733878,3285377520])},_doProcessBlock:function(d,e){for(var b=this._hash.words,n=b[0],j=b[1],h=b[2],g=b[3],l=b[4],a=0;80>a;a++){if(16>a)m[a]=d[e+a]|0;else{var c=m[a-3]^m[a-8]^m[a-14]^m[a-16];m[a]=c<<1|c>>>31}c=(n<<5|n>>>27)+l+m[a];c=20>a?c+((j&h|~j&g)+1518500249):40>a?c+((j^h^g)+1859775393):60>a?c+((j&h|j&g|h&g)-1894007588):c+((j^h^\ng)-899497514);l=g;g=h;h=j<<30|j>>>2;j=n;n=c}b[0]=b[0]+n|0;b[1]=b[1]+j|0;b[2]=b[2]+h|0;b[3]=b[3]+g|0;b[4]=b[4]+l|0},_doFinalize:function(){var d=this._data,e=d.words,b=8*this._nDataBytes,g=8*d.sigBytes;e[g>>>5]|=128<<24-g%32;e[(g+64>>>9<<4)+14]=Math.floor(b/4294967296);e[(g+64>>>9<<4)+15]=b;d.sigBytes=4*e.length;this._process();return this._hash},clone:function(){var e=d.clone.call(this);e._hash=this._hash.clone();return e}});g.SHA1=d._createHelper(l);g.HmacSHA1=d._createHmacHelper(l)})();\n(function(){var g=CryptoJS,l=g.enc.Utf8;g.algo.HMAC=g.lib.Base.extend({init:function(e,d){e=this._hasher=new e.init;\"string\"==typeof d&&(d=l.parse(d));var g=e.blockSize,k=4*g;d.sigBytes>k&&(d=e.finalize(d));d.clamp();for(var p=this._oKey=d.clone(),b=this._iKey=d.clone(),n=p.words,j=b.words,h=0;h<g;h++)n[h]^=1549556828,j[h]^=909522486;p.sigBytes=b.sigBytes=k;this.reset()},reset:function(){var e=this._hasher;e.reset();e.update(this._iKey)},update:function(e){this._hasher.update(e);return this},finalize:function(e){var d=\nthis._hasher;e=d.finalize(e);d.reset();return d.finalize(this._oKey.clone().concat(e))}})})();\n\n/**\n * Constructor\n * @param {Object} opts consumer key and secret\n */\nfunction OAuth(opts) {\n    if(!(this instanceof OAuth)) {\n        return new OAuth(opts);\n    }\n\n    if(!opts) {\n        opts = {};\n    }\n\n    if(!opts.consumer) {\n        throw new Error('consumer option is required');\n    }\n\n    this.consumer            = opts.consumer;\n    this.signature_method    = opts.signature_method || 'HMAC-SHA1';\n    this.nonce_length        = opts.nonce_length || 32;\n    this.version             = opts.version || '1.0';\n    this.parameter_seperator = opts.parameter_seperator || ', ';\n\n    if(typeof opts.last_ampersand === 'undefined') {\n        this.last_ampersand = true;\n    } else {\n        this.last_ampersand = opts.last_ampersand;\n    }\n\n    switch (this.signature_method) {\n        case 'HMAC-SHA1':\n            this.hash = function(base_string, key) {\n                return CryptoJS.HmacSHA1(base_string, key).toString(CryptoJS.enc.Base64);\n            };\n            break;\n        case 'PLAINTEXT':\n            this.hash = function(base_string, key) {\n                return key;\n            };\n            break;\n        case 'RSA-SHA1':\n            throw new Error('oauth-1.0a does not support this signature method right now. Coming Soon...');\n        default:\n            throw new Error('The OAuth 1.0a protocol defines three signature methods: HMAC-SHA1, RSA-SHA1, and PLAINTEXT only');\n    }\n}\n\n/**\n * OAuth request authorize\n * @param  {Object} request data\n * {\n *     method,\n *     url,\n *     data\n * }\n * @param  {Object} public and secret token\n * @return {Object} OAuth Authorized data\n */\nOAuth.prototype.authorize = function(request, token) {\n    var oauth_data = {\n        oauth_consumer_key: this.consumer.public,\n        oauth_nonce: this.getNonce(),\n        oauth_signature_method: this.signature_method,\n        oauth_timestamp: this.getTimeStamp(),\n        oauth_version: this.version\n    };\n\n    if(!token) {\n        token = {};\n    }\n\n    if(token.public) {\n        oauth_data.oauth_token = token.public;\n    }\n\n    if(!request.data) {\n        request.data = {};\n    }\n\n    oauth_data.oauth_signature = this.getSignature(request, token.secret, oauth_data);\n\n    return oauth_data;\n};\n\n/**\n * Create a OAuth Signature\n * @param  {Object} request data\n * @param  {Object} token_secret public and secret token\n * @param  {Object} oauth_data   OAuth data\n * @return {String} Signature\n */\nOAuth.prototype.getSignature = function(request, token_secret, oauth_data) {\n    return this.hash(this.getBaseString(request, oauth_data), this.getSigningKey(token_secret));\n};\n\n/**\n * Base String = Method + Base Url + ParameterString\n * @param  {Object} request data\n * @param  {Object} OAuth data\n * @return {String} Base String\n */\nOAuth.prototype.getBaseString = function(request, oauth_data) {\n    return request.method.toUpperCase() + '&' + this.percentEncode(this.getBaseUrl(request.url)) + '&' + this.percentEncode(this.getParameterString(request, oauth_data));\n};\n\n/**\n * Get data from url\n * -> merge with oauth data\n * -> percent encode key & value\n * -> sort\n * \n * @param  {Object} request data\n * @param  {Object} OAuth data\n * @return {Object} Parameter string data\n */\nOAuth.prototype.getParameterString = function(request, oauth_data) {\n    var base_string_data = this.sortObject(this.percentEncodeData(this.mergeObject(oauth_data, this.mergeObject(request.data, this.deParamUrl(request.url)))));\n\n    var data_str = '';\n\n    //base_string_data to string\n    for(var key in base_string_data) {\n        data_str += key + '=' + base_string_data[key] + '&';\n    }\n\n    //remove the last character\n    data_str = data_str.substr(0, data_str.length - 1);\n    return data_str;\n};\n\n/**\n * Create a Signing Key\n * @param  {String} token_secret Secret Token\n * @return {String} Signing Key\n */\nOAuth.prototype.getSigningKey = function(token_secret) {\n    token_secret = token_secret || '';\n\n    if(!this.last_ampersand && !token_secret) {\n        return this.percentEncode(this.consumer.secret);\n    }\n\n    return this.percentEncode(this.consumer.secret) + '&' + this.percentEncode(token_secret);\n};\n\n/**\n * Get base url\n * @param  {String} url\n * @return {String}\n */\nOAuth.prototype.getBaseUrl = function(url) {\n    return url.split('?')[0];\n};\n\n/**\n * Get data from String\n * @param  {String} string\n * @return {Object}\n */\nOAuth.prototype.deParam = function(string) {\n    var arr = decodeURIComponent(string).split('&');\n    var data = {};\n\n    for(var i = 0; i < arr.length; i++) {\n        var item = arr[i].split('=');\n        data[item[0]] = item[1];\n    }\n    return data;\n};\n\n/**\n * Get data from url\n * @param  {String} url\n * @return {Object}\n */\nOAuth.prototype.deParamUrl = function(url) {\n    var tmp = url.split('?');\n\n    if (tmp.length === 1)\n        return {};\n\n    return this.deParam(tmp[1]);\n};\n\n/**\n * Percent Encode\n * @param  {String} str\n * @return {String} percent encoded string\n */\nOAuth.prototype.percentEncode = function(str) {\n    return encodeURIComponent(str)\n        .replace(/\\!/g, \"%21\")\n        .replace(/\\*/g, \"%2A\")\n        .replace(/\\'/g, \"%27\")\n        .replace(/\\(/g, \"%28\")\n        .replace(/\\)/g, \"%29\");\n};\n\n/**\n * Percent Encode Object\n * @param  {Object} data\n * @return {Object} percent encoded data\n */\nOAuth.prototype.percentEncodeData = function(data) {\n    var result = {};\n\n    for(var key in data) {\n        result[this.percentEncode(key)] = this.percentEncode(data[key]);\n    }\n\n    return result;\n};\n\n/**\n * Get OAuth data as Header\n * @param  {Object} oauth_data\n * @return {String} Header data key - value\n */\nOAuth.prototype.toHeader = function(oauth_data) {\n    oauth_data = this.sortObject(oauth_data);\n\n    var header_value = 'OAuth ';\n\n    for(var key in oauth_data) {\n        if (key.indexOf('oauth_') === -1)\n            continue;\n        header_value += this.percentEncode(key) + '=\"' + this.percentEncode(oauth_data[key]) + '\"' + this.parameter_seperator;\n    }\n\n    return {\n        Authorization: header_value.substr(0, header_value.length - this.parameter_seperator.length) //cut the last chars\n    };\n};\n\n/**\n * Create a random word characters string with input length\n * @return {String} a random word characters string\n */\nOAuth.prototype.getNonce = function() {\n    var word_characters = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n    var result = '';\n\n    for(var i = 0; i < this.nonce_length; i++) {\n        result += word_characters[parseInt(Math.random() * word_characters.length, 10)];\n    }\n\n    return result;\n};\n\n/**\n * Get Current Unix TimeStamp\n * @return {Int} current unix timestamp\n */\nOAuth.prototype.getTimeStamp = function() {\n    return parseInt(new Date().getTime()/1000, 10);\n};\n\n////////////////////// HELPER FUNCTIONS //////////////////////\n\n/**\n * Merge object\n * @param  {Object} obj1\n * @param  {Object} obj2\n * @return {Object}\n */\nOAuth.prototype.mergeObject = function(obj1, obj2) {\n    var merged_obj = obj1;\n    for(var key in obj2) {\n        merged_obj[key] = obj2[key];\n    }\n    return merged_obj;\n};\n\n/**\n * Sort object by key\n * @param  {Object} data\n * @return {Object} sorted object\n */\nOAuth.prototype.sortObject = function(data) {\n    var keys = Object.keys(data);\n    var result = {};\n\n    keys.sort();\n\n    for(var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        result[key] = data[key];\n    }\n\n    return result;\n};\n\ndefine(\"lib/oauth\", function(){});\n\n",
    "var HANDJS = HANDJS || {};\n\n(function () {\n    // If the user agent already supports Pointer Events, do nothing\n    if (window.PointerEvent)\n        return;\n\n    // Polyfilling indexOf for old browsers\n    if (!Array.prototype.indexOf) {\n        Array.prototype.indexOf = function (searchElement) {\n            var t = Object(this);\n            var len = t.length >>> 0;\n            if (len === 0) {\n                return -1;\n            }\n            var n = 0;\n            if (arguments.length > 0) {\n                n = Number(arguments[1]);\n                if (n != n) { // shortcut for verifying if it's NaN\n                    n = 0;\n                } else if (n != 0 && n != Infinity && n != -Infinity) {\n                    n = (n > 0 || -1) * Math.floor(Math.abs(n));\n                }\n            }\n            if (n >= len) {\n                return -1;\n            }\n            var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);\n            for (; k < len; k++) {\n                if (k in t && t[k] === searchElement) {\n                    return k;\n                }\n            }\n            return -1;\n        };\n    }\n    //Polyfilling forEach for old browsers\n    if (!Array.prototype.forEach) {\n        Array.prototype.forEach = function (method, thisArg) {\n            if (!this || !(method instanceof Function))\n                throw new TypeError();\n            for (var i = 0; i < this.length; i++)\n                method.call(thisArg, this[i], i, this);\n        }\n    }\n  // Polyfilling trim for old browsers\n  if (!String.prototype.trim) {\n    String.prototype.trim = function () {\n      return this.replace(/^\\s+|\\s+$/, '');\n    };\n  }\n\n    // Installing Hand.js\n    var supportedEventsNames = [\"pointerdown\", \"pointerup\", \"pointermove\", \"pointerover\", \"pointerout\", \"pointercancel\", \"pointerenter\", \"pointerleave\"];\n    var upperCaseEventsNames = [\"PointerDown\", \"PointerUp\", \"PointerMove\", \"PointerOver\", \"PointerOut\", \"PointerCancel\", \"PointerEnter\", \"PointerLeave\"];\n\n    var POINTER_TYPE_TOUCH = \"touch\";\n    var POINTER_TYPE_PEN = \"pen\";\n    var POINTER_TYPE_MOUSE = \"mouse\";\n\n    var previousTargets = {};\n\n    var checkPreventDefault = function (node) {\n        while (node && !node.handjs_forcePreventDefault) {\n            node = node.parentNode;\n        }\n        return !!node || window.handjs_forcePreventDefault;\n    };\n\n    // Touch events\n    var generateTouchClonedEvent = function (sourceEvent, newName, canBubble, target, relatedTarget) {\n        // Considering touch events are almost like super mouse events\n        var evObj;\n        \n        if (document.createEvent) {\n            evObj = document.createEvent('MouseEvents');\n            evObj.initMouseEvent(newName, canBubble, true, window, 1, sourceEvent.screenX, sourceEvent.screenY,\n                sourceEvent.clientX, sourceEvent.clientY, sourceEvent.ctrlKey, sourceEvent.altKey,\n                sourceEvent.shiftKey, sourceEvent.metaKey, sourceEvent.button, relatedTarget || sourceEvent.relatedTarget);\n        }\n        else {\n            evObj = document.createEventObject();\n            evObj.screenX = sourceEvent.screenX;\n            evObj.screenY = sourceEvent.screenY;\n            evObj.clientX = sourceEvent.clientX;\n            evObj.clientY = sourceEvent.clientY;\n            evObj.ctrlKey = sourceEvent.ctrlKey;\n            evObj.altKey = sourceEvent.altKey;\n            evObj.shiftKey = sourceEvent.shiftKey;\n            evObj.metaKey = sourceEvent.metaKey;\n            evObj.button = sourceEvent.button;\n            evObj.relatedTarget = relatedTarget || sourceEvent.relatedTarget;\n        }\n        // offsets\n        if (evObj.offsetX === undefined) {\n            if (sourceEvent.offsetX !== undefined) {\n\n                // For Opera which creates readonly properties\n                if (Object && Object.defineProperty !== undefined) {\n                    Object.defineProperty(evObj, \"offsetX\", {\n                        writable: true\n                    });\n                    Object.defineProperty(evObj, \"offsetY\", {\n                        writable: true\n                    });\n                }\n\n                evObj.offsetX = sourceEvent.offsetX;\n                evObj.offsetY = sourceEvent.offsetY;\n            } else if (Object && Object.defineProperty !== undefined) {\n                Object.defineProperty(evObj, \"offsetX\", {\n                    get: function () {\n                        if (this.currentTarget && this.currentTarget.offsetLeft) {\n                            return sourceEvent.clientX - this.currentTarget.offsetLeft;\n                        }\n                        return sourceEvent.clientX;\n                    }\n                });\n                Object.defineProperty(evObj, \"offsetY\", {\n                    get: function () {\n                        if (this.currentTarget && this.currentTarget.offsetTop) {\n                            return sourceEvent.clientY - this.currentTarget.offsetTop;\n                        }\n                        return sourceEvent.clientY;\n                    }\n                });\n            }\n            else if (sourceEvent.layerX !== undefined) {\n                evObj.offsetX = sourceEvent.layerX - sourceEvent.currentTarget.offsetLeft;\n                evObj.offsetY = sourceEvent.layerY - sourceEvent.currentTarget.offsetTop;\n            }\n        }\n\n        // adding missing properties\n\n        if (sourceEvent.isPrimary !== undefined)\n            evObj.isPrimary = sourceEvent.isPrimary;\n        else\n            evObj.isPrimary = true;\n\n        if (sourceEvent.pressure)\n            evObj.pressure = sourceEvent.pressure;\n        else {\n            var button = 0;\n\n            if (sourceEvent.which !== undefined)\n                button = sourceEvent.which;\n            else if (sourceEvent.button !== undefined) {\n                button = sourceEvent.button;\n            }\n            evObj.pressure = (button == 0) ? 0 : 0.5;\n        }\n\n\n        if (sourceEvent.rotation)\n            evObj.rotation = sourceEvent.rotation;\n        else\n            evObj.rotation = 0;\n\n        // Timestamp\n        if (sourceEvent.hwTimestamp)\n            evObj.hwTimestamp = sourceEvent.hwTimestamp;\n        else\n            evObj.hwTimestamp = 0;\n\n        // Tilts\n        if (sourceEvent.tiltX)\n            evObj.tiltX = sourceEvent.tiltX;\n        else\n            evObj.tiltX = 0;\n\n        if (sourceEvent.tiltY)\n            evObj.tiltY = sourceEvent.tiltY;\n        else\n            evObj.tiltY = 0;\n\n        // Width and Height\n        if (sourceEvent.height)\n            evObj.height = sourceEvent.height;\n        else\n            evObj.height = 0;\n\n        if (sourceEvent.width)\n            evObj.width = sourceEvent.width;\n        else\n            evObj.width = 0;\n\n        // preventDefault\n        evObj.preventDefault = function () {\n            if (sourceEvent.preventDefault !== undefined)\n                sourceEvent.preventDefault();\n        };\n\n        // stopPropagation\n        if (evObj.stopPropagation !== undefined) {\n            var current = evObj.stopPropagation;\n            evObj.stopPropagation = function () {\n                if (sourceEvent.stopPropagation !== undefined)\n                    sourceEvent.stopPropagation();\n                current.call(this);\n            };\n        }\n\n        // Pointer values\n        evObj.pointerId = sourceEvent.pointerId;\n        evObj.pointerType = sourceEvent.pointerType;\n\n        switch (evObj.pointerType) {// Old spec version check\n            case 2:\n                evObj.pointerType = POINTER_TYPE_TOUCH;\n                break;\n            case 3:\n                evObj.pointerType = POINTER_TYPE_PEN;\n                break;\n            case 4:\n                evObj.pointerType = POINTER_TYPE_MOUSE;\n                break;\n        }\n\n        // Fire event\n        if (target)\n            target.dispatchEvent(evObj);\n        else if (sourceEvent.target) {\n            sourceEvent.target.dispatchEvent(evObj);\n        } else {\n            sourceEvent.srcElement.fireEvent(\"on\" + getMouseEquivalentEventName(newName), evObj); // We must fallback to mouse event for very old browsers\n        }\n    };\n\n    var generateMouseProxy = function (evt, eventName, canBubble, target, relatedTarget) {\n        evt.pointerId = 1;\n        evt.pointerType = POINTER_TYPE_MOUSE;\n        generateTouchClonedEvent(evt, eventName, canBubble, target, relatedTarget);\n    };\n\n    var generateTouchEventProxy = function (name, touchPoint, target, eventObject, canBubble, relatedTarget) {\n        var touchPointId = touchPoint.identifier + 2; // Just to not override mouse id\n\n        touchPoint.pointerId = touchPointId;\n        touchPoint.pointerType = POINTER_TYPE_TOUCH;\n        touchPoint.currentTarget = target;\n\n        if (eventObject.preventDefault !== undefined) {\n            touchPoint.preventDefault = function () {\n                eventObject.preventDefault();\n            };\n        }\n\n        generateTouchClonedEvent(touchPoint, name, canBubble, target, relatedTarget);\n    };\n\n    var checkEventRegistration = function (node, eventName) {\n        return node.__handjsGlobalRegisteredEvents && node.__handjsGlobalRegisteredEvents[eventName];\n    }\n    var findEventRegisteredNode = function (node, eventName) {\n        while (node && !checkEventRegistration(node, eventName))\n            node = node.parentNode;\n        if (node)\n            return node;\n        else if (checkEventRegistration(window, eventName))\n            return window;\n    };\n\n    var generateTouchEventProxyIfRegistered = function (eventName, touchPoint, target, eventObject, canBubble, relatedTarget) { // Check if user registered this event\n        if (findEventRegisteredNode(target, eventName)) {\n            generateTouchEventProxy(eventName, touchPoint, target, eventObject, canBubble, relatedTarget);\n        }\n    };\n\n    //var handleOtherEvent = function (eventObject, name, useLocalTarget, checkRegistration) {\n    //    if (eventObject.preventManipulation)\n    //        eventObject.preventManipulation();\n\n    //    for (var i = 0; i < eventObject.changedTouches.length; ++i) {\n    //        var touchPoint = eventObject.changedTouches[i];\n\n    //        if (useLocalTarget) {\n    //            previousTargets[touchPoint.identifier] = touchPoint.target;\n    //        }\n\n    //        if (checkRegistration) {\n    //            generateTouchEventProxyIfRegistered(name, touchPoint, previousTargets[touchPoint.identifier], eventObject, true);\n    //        } else {\n    //            generateTouchEventProxy(name, touchPoint, previousTargets[touchPoint.identifier], eventObject, true);\n    //        }\n    //    }\n    //};\n\n    var getMouseEquivalentEventName = function (eventName) {\n        return eventName.toLowerCase().replace(\"pointer\", \"mouse\");\n    };\n\n    var getPrefixEventName = function (prefix, eventName) {\n        var upperCaseIndex = supportedEventsNames.indexOf(eventName);\n        var newEventName = prefix + upperCaseEventsNames[upperCaseIndex];\n\n        return newEventName;\n    };\n\n    var registerOrUnregisterEvent = function (item, name, func, enable) {\n        if (item.__handjsRegisteredEvents === undefined) {\n            item.__handjsRegisteredEvents = [];\n        }\n\n        if (enable) {\n            if (item.__handjsRegisteredEvents[name] !== undefined) {\n                item.__handjsRegisteredEvents[name]++;\n                return;\n            }\n\n            item.__handjsRegisteredEvents[name] = 1;\n            item.addEventListener(name, func, false);\n        } else {\n\n            if (item.__handjsRegisteredEvents.indexOf(name) !== -1) {\n                item.__handjsRegisteredEvents[name]--;\n\n                if (item.__handjsRegisteredEvents[name] != 0) {\n                    return;\n                }\n            }\n            item.removeEventListener(name, func);\n            item.__handjsRegisteredEvents[name] = 0;\n        }\n    };\n\n    var setTouchAware = function (item, eventName, enable) {\n        // Leaving tokens\n        if (!item.__handjsGlobalRegisteredEvents) {\n            item.__handjsGlobalRegisteredEvents = [];\n        }\n        if (enable) {\n            if (item.__handjsGlobalRegisteredEvents[eventName] !== undefined) {\n                item.__handjsGlobalRegisteredEvents[eventName]++;\n                return;\n            }\n            item.__handjsGlobalRegisteredEvents[eventName] = 1;\n        } else {\n            if (item.__handjsGlobalRegisteredEvents[eventName] !== undefined) {\n                item.__handjsGlobalRegisteredEvents[eventName]--;\n                if (item.__handjsGlobalRegisteredEvents[eventName] < 0) {\n                    item.__handjsGlobalRegisteredEvents[eventName] = 0;\n                }\n            }\n        }\n\n        var nameGenerator;\n        var eventGenerator;\n        if (window.MSPointerEvent) {\n            nameGenerator = function (name) { return getPrefixEventName(\"MS\", name); };\n            eventGenerator = generateTouchClonedEvent;\n        }\n        else {\n            nameGenerator = getMouseEquivalentEventName;\n            eventGenerator = generateMouseProxy;\n        }\n        switch (eventName) {\n            case \"pointerenter\":\n            case \"pointerleave\":\n                var targetEvent = nameGenerator(eventName);\n                if (item['on' + targetEvent.toLowerCase()] !== undefined) {\n                    registerOrUnregisterEvent(item, targetEvent, function (evt) { eventGenerator(evt, eventName); }, enable);\n                }\n                break;\n        }\n    };\n\n    // Intercept addEventListener calls by changing the prototype\n    var interceptAddEventListener = function (root) {\n        var current = root.prototype ? root.prototype.addEventListener : root.addEventListener;\n\n        var customAddEventListener = function (name, func, capture) {\n            // Branch when a PointerXXX is used\n            if (supportedEventsNames.indexOf(name) != -1) {\n                setTouchAware(this, name, true);\n            }\n\n            if (current === undefined) {\n                this.attachEvent(\"on\" + getMouseEquivalentEventName(name), func);\n            } else {\n                current.call(this, name, func, capture);\n            }\n        };\n\n        if (root.prototype) {\n            root.prototype.addEventListener = customAddEventListener;\n        } else {\n            root.addEventListener = customAddEventListener;\n        }\n    };\n\n    // Intercept removeEventListener calls by changing the prototype\n    var interceptRemoveEventListener = function (root) {\n        var current = root.prototype ? root.prototype.removeEventListener : root.removeEventListener;\n\n        var customRemoveEventListener = function (name, func, capture) {\n            // Release when a PointerXXX is used\n            if (supportedEventsNames.indexOf(name) != -1) {\n                setTouchAware(this, name, false);\n            }\n\n            if (current === undefined) {\n                this.detachEvent(getMouseEquivalentEventName(name), func);\n            } else {\n                current.call(this, name, func, capture);\n            }\n        };\n        if (root.prototype) {\n            root.prototype.removeEventListener = customRemoveEventListener;\n        } else {\n            root.removeEventListener = customRemoveEventListener;\n        }\n    };\n\n    // Hooks\n    interceptAddEventListener(window);\n    interceptAddEventListener(window.HTMLElement || window.Element);\n    interceptAddEventListener(document);\n    interceptAddEventListener(HTMLBodyElement);\n    interceptAddEventListener(HTMLDivElement);\n    interceptAddEventListener(HTMLImageElement);\n    interceptAddEventListener(HTMLUListElement);\n    interceptAddEventListener(HTMLAnchorElement);\n    interceptAddEventListener(HTMLLIElement);\n    interceptAddEventListener(HTMLTableElement);\n    if (window.HTMLSpanElement) {\n        interceptAddEventListener(HTMLSpanElement);\n    }\n    if (window.HTMLCanvasElement) {\n        interceptAddEventListener(HTMLCanvasElement);\n    }\n    if (window.SVGElement) {\n        interceptAddEventListener(SVGElement);\n    }\n\n    interceptRemoveEventListener(window);\n    interceptRemoveEventListener(window.HTMLElement || window.Element);\n    interceptRemoveEventListener(document);\n    interceptRemoveEventListener(HTMLBodyElement);\n    interceptRemoveEventListener(HTMLDivElement);\n    interceptRemoveEventListener(HTMLImageElement);\n    interceptRemoveEventListener(HTMLUListElement);\n    interceptRemoveEventListener(HTMLAnchorElement);\n    interceptRemoveEventListener(HTMLLIElement);\n    interceptRemoveEventListener(HTMLTableElement);\n    if (window.HTMLSpanElement) {\n        interceptRemoveEventListener(HTMLSpanElement);\n    }\n    if (window.HTMLCanvasElement) {\n        interceptRemoveEventListener(HTMLCanvasElement);\n    }\n    if (window.SVGElement) {\n        interceptRemoveEventListener(SVGElement);\n    }\n\n    // Prevent mouse event from being dispatched after Touch Events action\n    var touching = false;\n    var touchTimer = -1;\n\n    function setTouchTimer() {\n        touching = true;\n        clearTimeout(touchTimer);\n        touchTimer = setTimeout(function () {\n            touching = false;\n        }, 700);\n        // 1. Mobile browsers dispatch mouse events 300ms after touchend\n        // 2. Chrome for Android dispatch mousedown for long-touch about 650ms\n        // Result: Blocking Mouse Events for 700ms.\n    }\n\n    function getDomUpperHierarchy(node) {\n        var nodes = [];\n        if (node) {\n            nodes.unshift(node);\n            while (node.parentNode) {\n                nodes.unshift(node.parentNode);\n                node = node.parentNode;\n            }\n        }\n        return nodes;\n    }\n\n    function getFirstCommonNode(node1, node2) {\n        var parents1 = getDomUpperHierarchy(node1);\n        var parents2 = getDomUpperHierarchy(node2);\n\n        var lastmatch = null\n        while (parents1.length > 0 && parents1[0] == parents2.shift())\n            lastmatch = parents1.shift();\n        return lastmatch;\n    }\n\n    //generateProxy receives a node to dispatch the event\n    function dispatchPointerEnter(currentTarget, relatedTarget, generateProxy) {\n        var commonParent = getFirstCommonNode(currentTarget, relatedTarget);\n        var node = currentTarget;\n        var nodelist = [];\n        while (node && node != commonParent) {//target range: this to the direct child of parent relatedTarget\n            if (checkEventRegistration(node, \"pointerenter\")) //check if any parent node has pointerenter\n                nodelist.push(node);\n            node = node.parentNode;\n        }\n        while (nodelist.length > 0)\n            generateProxy(nodelist.pop());\n    }\n\n    //generateProxy receives a node to dispatch the event\n    function dispatchPointerLeave(currentTarget, relatedTarget, generateProxy) {\n        var commonParent = getFirstCommonNode(currentTarget, relatedTarget);\n        var node = currentTarget;\n        while (node && node != commonParent) {//target range: this to the direct child of parent relatedTarget\n            if (checkEventRegistration(node, \"pointerleave\"))//check if any parent node has pointerleave\n                generateProxy(node);\n            node = node.parentNode;\n        }\n    }\n    \n    // Handling events on window to prevent unwanted super-bubbling\n    // All mouse events are affected by touch fallback\n    function applySimpleEventTunnels(nameGenerator, eventGenerator) {\n        [\"pointerdown\", \"pointermove\", \"pointerup\", \"pointerover\", \"pointerout\"].forEach(function (eventName) {\n            window.addEventListener(nameGenerator(eventName), function (evt) {\n                if (!touching && findEventRegisteredNode(evt.target, eventName))\n                    eventGenerator(evt, eventName, true);\n            });\n        });\n        if (window['on' + nameGenerator(\"pointerenter\").toLowerCase()] === undefined)\n            window.addEventListener(nameGenerator(\"pointerover\"), function (evt) {\n                if (touching)\n                    return;\n                var foundNode = findEventRegisteredNode(evt.target, \"pointerenter\");\n                if (!foundNode || foundNode === window)\n                    return;\n                else if (!foundNode.contains(evt.relatedTarget)) {\n                    dispatchPointerEnter(foundNode, evt.relatedTarget, function (targetNode) {\n                        eventGenerator(evt, \"pointerenter\", false, targetNode, evt.relatedTarget);\n                    });\n                }\n            });\n        if (window['on' + nameGenerator(\"pointerleave\").toLowerCase()] === undefined)\n            window.addEventListener(nameGenerator(\"pointerout\"), function (evt) {\n                if (touching)\n                    return;\n                var foundNode = findEventRegisteredNode(evt.target, \"pointerleave\");\n                if (!foundNode || foundNode === window)\n                    return;\n                else if (!foundNode.contains(evt.relatedTarget)) {\n                    dispatchPointerLeave(foundNode, evt.relatedTarget, function (targetNode) {\n                        eventGenerator(evt, \"pointerleave\", false, targetNode, evt.relatedTarget);\n                    });\n                }\n            });\n    }\n\n    (function () {\n        if (window.MSPointerEvent) {\n            //IE 10\n            applySimpleEventTunnels(\n                function (name) { return getPrefixEventName(\"MS\", name); },\n                generateTouchClonedEvent);\n        }\n        else {\n            applySimpleEventTunnels(getMouseEquivalentEventName, generateMouseProxy);\n\n            // Handling move on window to detect pointerleave/out/over\n            if (window.ontouchstart !== undefined) {\n                window.addEventListener('touchstart', function (eventObject) {\n                    for (var i = 0; i < eventObject.changedTouches.length; ++i) {\n                        var touchPoint = eventObject.changedTouches[i];\n                        previousTargets[touchPoint.identifier] = touchPoint.target;\n\n                        generateTouchEventProxyIfRegistered(\"pointerover\", touchPoint, touchPoint.target, eventObject, true);\n\n                        //pointerenter should not be bubbled\n                        dispatchPointerEnter(touchPoint.target, null, function (targetNode) {\n                            generateTouchEventProxy(\"pointerenter\", touchPoint, targetNode, eventObject, false);\n                        })\n\n                        generateTouchEventProxyIfRegistered(\"pointerdown\", touchPoint, touchPoint.target, eventObject, true);\n                    }\n                    setTouchTimer();\n                });\n\n                window.addEventListener('touchend', function (eventObject) {\n                    for (var i = 0; i < eventObject.changedTouches.length; ++i) {\n                        var touchPoint = eventObject.changedTouches[i];\n                        var currentTarget = previousTargets[touchPoint.identifier];\n\n                        generateTouchEventProxyIfRegistered(\"pointerup\", touchPoint, currentTarget, eventObject, true);\n                        generateTouchEventProxyIfRegistered(\"pointerout\", touchPoint, currentTarget, eventObject, true);\n\n                        //pointerleave should not be bubbled\n                        dispatchPointerLeave(currentTarget, null, function (targetNode) {\n                            generateTouchEventProxy(\"pointerleave\", touchPoint, targetNode, eventObject, false);\n                        })\n                    }\n                    setTouchTimer();\n                });\n\n                window.addEventListener('touchmove', function (eventObject) {\n                    for (var i = 0; i < eventObject.changedTouches.length; ++i) {\n                        var touchPoint = eventObject.changedTouches[i];\n                        var newTarget = document.elementFromPoint(touchPoint.clientX, touchPoint.clientY);\n                        var currentTarget = previousTargets[touchPoint.identifier];\n\n                        // If force preventDefault\n                        if (currentTarget && checkPreventDefault(currentTarget) === true)\n                            eventObject.preventDefault();\n\n                        generateTouchEventProxyIfRegistered(\"pointermove\", touchPoint, currentTarget, eventObject, true);\n\n                        if (currentTarget === newTarget) {\n                            continue; // We can skip this as the pointer is effectively over the current target\n                        }\n\n                        if (currentTarget) {\n                            // Raise out\n                            generateTouchEventProxyIfRegistered(\"pointerout\", touchPoint, currentTarget, eventObject, true, newTarget);\n\n                            // Raise leave\n                            if (!currentTarget.contains(newTarget)) { // Leave must be called if the new target is not a child of the current\n                                dispatchPointerLeave(currentTarget, newTarget, function (targetNode) {\n                                    generateTouchEventProxy(\"pointerleave\", touchPoint, targetNode, eventObject, false, newTarget);\n                                });\n                            }\n                        }\n\n                        if (newTarget) {\n                            // Raise over\n                            generateTouchEventProxyIfRegistered(\"pointerover\", touchPoint, newTarget, eventObject, true, currentTarget);\n\n                            // Raise enter\n                            if (!newTarget.contains(currentTarget)) { // Leave must be called if the new target is not the parent of the current\n                                dispatchPointerEnter(newTarget, currentTarget, function (targetNode) {\n                                    generateTouchEventProxy(\"pointerenter\", touchPoint, targetNode, eventObject, false, currentTarget);\n                                })\n                            }\n                        }\n                        previousTargets[touchPoint.identifier] = newTarget;\n                    }\n                    setTouchTimer();\n                });\n\n                window.addEventListener('touchcancel', function (eventObject) {\n                    for (var i = 0; i < eventObject.changedTouches.length; ++i) {\n                        var touchPoint = eventObject.changedTouches[i];\n\n                        generateTouchEventProxyIfRegistered(\"pointercancel\", touchPoint, previousTargets[touchPoint.identifier], eventObject, true);\n                    }\n                });\n            }\n        }\n    })();\n    \n\n    // Extension to navigator\n    if (navigator.pointerEnabled === undefined) {\n\n        // Indicates if the browser will fire pointer events for pointing input\n        navigator.pointerEnabled = true;\n\n        // IE\n        if (navigator.msPointerEnabled) {\n            navigator.maxTouchPoints = navigator.msMaxTouchPoints;\n        }\n    }\n\n    // Handling touch-action css rule\n    if (document.styleSheets && document.addEventListener) {\n        document.addEventListener(\"DOMContentLoaded\", function () {\n            if (HANDJS.doNotProcessCSS || document.body.style.touchAction !== undefined) {//Chrome is trying to implement touch-action before Pointer Events listeners\n                return;\n            }\n            \n            var globalRegex = new RegExp(\".+?{.*?}\", \"m\");\n            var selectorRegex = new RegExp(\".+?{\", \"m\");\n            var filterStylesheet = function (unfilteredSheet) {\n                var filter = globalRegex.exec(unfilteredSheet);\n                if (!filter) {\n                    return;\n                }\n                var block = filter[0];\n                unfilteredSheet = unfilteredSheet.replace(block, \"\").trim();\n                var selectorText = selectorRegex.exec(block)[0].replace(\"{\", \"\").trim();\n\n                // Checking if the user wanted to deactivate the default behavior\n                if (block.replace(/\\s/g, \"\").indexOf(\"touch-action:none\") != -1) {\n                    var elements = document.querySelectorAll(selectorText);\n\n                    for (var elementIndex = 0; elementIndex < elements.length; elementIndex++) {\n                        var element = elements[elementIndex];\n\n                        if (element.style.msTouchAction !== undefined) {\n                            element.style.msTouchAction = \"none\";\n                        }\n                        else {\n                            element.handjs_forcePreventDefault = true;\n                        }\n                    }\n                }\n                return unfilteredSheet;\n            }\n            var processStylesheet = function (unfilteredSheet) {\n                if (window.setImmediate) {//not blocking UI interaction for a long time\n                    if (unfilteredSheet)\n                        setImmediate(processStylesheet, filterStylesheet(unfilteredSheet));\n                }\n                else {\n                    while (unfilteredSheet) {\n                        unfilteredSheet = filterStylesheet(unfilteredSheet);\n                    }\n                }\n            }; // Looking for touch-action in referenced stylesheets\n            try {\n                for (var index = 0; index < document.styleSheets.length; index++) {\n                    var sheet = document.styleSheets[index];\n\n                    if (sheet.href == undefined) { // it is an inline style\n                        continue;\n                    }\n\n                    // Loading the original stylesheet\n                    var xhr = new XMLHttpRequest();\n                    xhr.open(\"get\", sheet.href);\n                    xhr.send();\n\n                    var unfilteredSheet = xhr.responseText.replace(/(\\n|\\r)/g, \"\");\n\n                    processStylesheet(unfilteredSheet);\n                }\n            } catch (e) {\n                // Silently fail...\n            }\n\n            // Looking for touch-action in inline styles\n            var styles = document.getElementsByTagName(\"style\");\n            for (var index = 0; index < styles.length; index++) {\n                var inlineSheet = styles[index];\n\n                var inlineUnfilteredSheet = inlineSheet.innerHTML.replace(/(\\n|\\r)/g, \"\").trim();\n\n                processStylesheet(inlineUnfilteredSheet);\n            }\n        }, false);\n    }\n\n})();\ndefine(\"lib/handjs-1.8.3\", function(){});\n\n",
    "/** \n* @module StampSDK-js\n* @author John Sphar <jlsphar@snowshoestamp.com>\n* @requires util - Utility module w/ subclassing sugar and uuid/base64 generation.\n* @requires handjs-1.8.3 - Microsoft's HandJS touch polyfill.\n* @requires json3 - The JSON polyfill.\n* @TODO delete any utility methods not being used\n* @TODO add support for oAuth2.0 and option to switch between oAuth1.0a and oAuth2.0\n*/\ndefine('stampsdk',[\n  'lib/util',\n  'lib/oauth',\n  'lib/handjs-1.8.3'\n], function(util) { 'use strict';\n  var\n    /** \n    * @TODO integrate keen for usage data sharing\n    * @TODO add option for user to disable usage data sharing\n    */\n    keen,\n\n    /**\n    * Version for the oAuth endpoint\n    * @constant OAUTH_VERSION\n    * @TODO add oauth2.0 support\n    */\n    OAUTH_VERSION = 1,\n\n    /**\n    * Endpoint for the SnowShoeStamp API\n    * @constant DOMAIN - Base URL for the snowshoestamp endpoing.\n    * @constant SSSAPIQ - The SnowShoeStamp endpoint.\n    */\n    DOMAIN = 'http://dev2.snowshoestamp.com/',\n    SSSAPIQ = DOMAIN + 'api/v2/stamp',\n\n    /**\n    * How many miliseconds between points. Modify as necessary, maybe even a different value per device.\n    * @constant {number} STAMP_THRESHHOLD\n    */\n    STAMP_THRESHHOLD = 500,\n\n    /**\n    * How much time needs to be in between different stamps for them to be recognized?\n    * @constant {number} MIN_TIME_BETWEEN_STAMPS\n    */\n    MIN_TIME_BETWEEN_STAMPS = 500,\n\n    /**\n    * How many points per stamp?\n    * @constant {number} MIN_POINTS_PER_STAMP\n    */\n    MIN_POINTS_PER_STAMP = 5,\n\n    /**\n    * The ID for the consumer client.\n    * @prop {string} clientId\n    * @TODO implement clientId\n    */\n    clientId,\n\n    /**\n    * The secret for Mobile-side authentication.\n    * @prop {string} clientSecret\n    * @TODO implement clientSecret\n    */\n    clientSecret,\n\n    /**\n    * The stamp spots for a stamp.\n    * @prop stampSpots\n    */\n    stampSpots = {},\n\n    /**\n    * Represents the area for a points stamp.\n    * @class Stamp\n    * @param {string} [options.accessToken]\n    * @param {string|number} [options.spotId]\n    * @param {string|number} [options.stampSerial]\n    */\n    Stamp = function(options) {\n      var _this = this;\n\n      _this.options = util.merge(options || {}, _this.defaults);\n\n      /** \n      * The spotId this stamp was recognized on.\n      * @prop {string} spotId\n      */\n      _this.spotId = _this.options.spotId;\n\n      /** \n      * The globally-unique identifier for this stamp.\n      * @prop {string} stampSerial\n      */\n      _this.stampSerial = _this.options.stampSerial;\n\n      /**\n      * Set the stampSerial for this stamp.\n      * @method setStampSerial\n      * @param {string} stampSerial - The stampSerial for this stamp. \n      */\n      _this.setStampSerial = function(stampSerial) {\n        _this.stampSerial = stampSerial;\n      };\n    }, // end Stamp class\n\n    /**\n    * Spots on the user interface where stamps are planning on being registered.\n    * @class StampSpot\n    * @param {object} [options.spot] - The element to bind to\n    * @param {string | number} [options.spotId] - The identifier for this spot\n    */\n    StampSpot = function(options, fn) {\n      var _this = this;\n      _this.options = util.merge(options || {}, _this.defaults);\n\n      /**\n      * The stamps which have been detected on this spot.\n      * @prop {Array} stamps\n      */\n      _this.stamps = [];\n      /**\n      * The unique ID for the stampSpot.\n      * @prop {string} spotId\n      */\n      _this.spotId = _this.options.spotId;\n\n      /**\n      * The user-defined success method.\n      * @method {function} success\n      */\n      _this.success = options.success;\n\n      /**\n      * The user defined failure method\n      * @method {function} failure\n      */\n      _this.failure = options.failure;\n\n      /**\n      * Pre-validation method.\n      * @method {function} pre\n      * @param {array} points - The coordinates for the SSS endpoint request.\n      */\n      _this.pre = options.pre;\n\n      /**\n      * The time the stamping begun.\n      * @prop {epoch} _pressBegun\n      */\n      _this._pressBegun = (new Date()).getTime();\n\n      /**\n      * Collection of point events\n      * @namespace\n      * @prop {array} _points.0\n      * @prop {array} _points.1\n      * @prop {array} _points.2\n      * @prop {array} _points.3\n      * @prop {array} _points.4\n      */\n      _this._points = {};\n\n      /**\n      * When the last stamp was detected.\n      * @prop {epoch | undefined} _lastStamped\n      */\n      _this._lastStamped = undefined;\n\n      /**\n      * This event fires when a StampType on the Spot has been verified via the SSS API.\n      * @method success\n      * @param {object} args - The response from the server.\n      * @param {string} args.receipt - The uuid base64 digest for this api call.\n      * @param {string} args.created - The ISO8601 timedate string for this api call.\n      * @param {securet} args.secure - Whether or not this app is secure.\n      * @param {string} args.stamp.serial - The serial for this stamp.\n      * @example args (success)\n      *   {\n      *     'receipt': <base64 digest>,\n      *     'created': <ISO8601 time string>,\n      *     'secure': <(true | false)>\n      *     'stamp': { 'serial': <serial_string> }\n      *   }\n      */\n      _this.onSuccess = function(args) {\n        keen.track('stampscreen', {\n          'type': 'successful stamp',\n          'details': args\n        });\n        this.success(args);\n      };\n\n      /**\n      * @method onFailure\n      * @param args\n      * @param {string} args.receipt - Base64 Digest of the Receipt\n      * @param {string} args.created - ISO8601 datetime string\n      * @param {boolean} args.secure - Whether or not this session was secure\n      * @param {object} args.error - The error data\n      * @param {string} args.error.message - The reason for the error. Either 'Stamp not found', 'Argument parse error', \n      * @param {number} args.error.code - The code number for the particular error. Either 32, 30, or 31, respectively.\n      * @param {number} args.error.http_status - Always will be 400 upon error or 'Wrong number of points'.\n      */\n      _this.onFailure = function(args) {\n        keen.track('stampscreen', {\n          'type': 'failed stamp',\n          'details': args\n        });\n        this.failure(args);\n      };\n\n      /**\n      * Reset the point information.\n      * @method _resetPoints\n      */\n      _this._resetPoints = function() {\n        _this._points = {};\n      };\n\n      /**\n      * Get point coordinates.\n      * @method _getPointCoords\n      */\n      _this._getPointCoords = function() {\n        var out = [];\n        // check to see how we should format this coordinate system\n        for (var k in _this._points) {\n          out.push([_this._points[k].clientX,_this._points[k].clientY]);\n        }\n        return out;\n      };\n\n      /**\n      * Send the coordinates to be validated against the URL.\n      * @param {array} points - The coordinates of the stamp.\n      * @returns {object | boolean} interface - If validation was successful, return the interface to the Stamp.\n      * @TODO look up and check the response.stampSerial (what's actually sent through?)\n      */\n      _this._validate = function(_points) {\n        var \n          req = util.createCORSRequest('POST', SSSAPIQ),\n          reqData = new FormData(),\n          oauthClient = new OAuth({\n            'consumer': {\n              'secret': clientSecret,\n              'public': clientId\n            }\n          }),\n          oauthData,\n          authDict,\n  \n          /**\n          * Load event for the XHR request.\n          * @event load\n          */\n          reqOnLoad = function(e) {\n            console.debug(req.response);\n            var \n              resp = JSON.parse(req.response),\n              stamp = resp.stamp,\n              stampSerial = stamp !== undefined ? stamp.serial : undefined,\n              hasBeenStamped = false,\n              matches;\n\n            if (stampSerial === undefined) {\n              console.error(err.message);\n              _this.onFailure(resp);\n              return;\n            }\n\n            theStamp = new Stamp({\n              'spotId': _this.spotId,\n              'stampSerial': (stampSerial !== undefined ? stampSerial : undefined)\n            });\n\n            match = _this.stamps.filter(function(s) {\n              return s.stampSerial === theStamp.stampSerial;\n            });\n\n            if (match && match.length === 1) {\n              match[0].pressed();\n              hasBeenStamped = true;\n            } else {\n              _this.stamps.push(theStamp);\n            }\n\n            _this._lastStamped = now;\n\n            _this.onSuccess(resp);\n          },\n\n          reqOnError = function(e) {\n            var\n              resp = req.response;\n            _this.onFailure(resp);\n          };\n\n        _this.pre(_points, function() {\n          if (req === null) {\n            throw new Error(\"CORSNotSupported\");\n          } else {\n            req.withCredentials = true;\n            req.onerror = reqOnError;\n            req.onload = reqOnLoad;\n\n            oauthData = oauthClient.authorize({\n                url: SSSAPIQ,\n                method: 'POST',\n                data: reqData\n            });\n\n            authDict = oauthClient.toHeader(oauthData);\n\n            // setup oAuth1.0a\n            req.setRequestHeader('Authorization', authDict.Authorization);\n            req.send(oauthData);\n\n            // 2. Setup the oAuth string\n            reqData.append('data', util.base64.encode(JSON.stringify(_points)));\n          }\n\n        });\n      };\n\n      /**\n      * Triggers during the pointdown event on the element.\n      * @method _pointdown\n      */\n      _this._pointdown = function(evt) {\n        var \n          now = (new Date()).getTime(),\n          points = [evt.clientX, evt.clientY],\n          fromBegun = now - _this._pressBegun,\n          sinceLastStamp = now - _this._lastStamped,\n          validStampTime = (_this._lastStamped === undefined || sinceLastStamp > MIN_TIME_BETWEEN_STAMPS),\n          validPressTime = fromBegun < STAMP_THRESHHOLD,\n          coords,\n          theStamp,\n          req,\n          data;\n\n        evt.preventDefault();\n\n        if (!validPressTime) {\n          _this._resetPoints();\n          _this._pressBegun = (new Date()).getTime();\n        }\n\n        // get coordinates without this guy w/o the new pointset (no race condition)\n        coords = _this._getPointCoords();\n\n        if (_this._points[evt.pointerId] === undefined && validStampTime) {\n          // add this new point to the set before grabbing the coordinates\n          coords.push([evt.clientX, evt.clientY]);\n\n          // define this event in the _points\n          _this._points[evt.pointerId] = util.extend({},evt,true);\n          \n          // is quite possibly a complete stamp\n          if (coords.length === MIN_POINTS_PER_STAMP) {\n            // call keen if it's there\n            if (keen !== undefined) {\n              keen.track('stampscreen', {\n                'type': 'points captured'\n              });\n            }\n            // validate the stamp\n            _this._validate(coords);\n            // reset the points\n            _this._resetPoints();\n          }\n        }\n      }; // end of _this._pointdown(evt) { ... }\n\n      /**\n      * @method _pointup\n      * @param {event} evt - The event for the stamp.\n      */\n      _this._pointup = function(evt) {\n        if (_this._points[evt.pointerId]) {\n          delete _this._points[evt.pointerId];\n        }\n      };\n\n      /**\n      * @method _pointmove\n      * @param {event} evt - The event for the point movement.\n      */\n      _this._pointmove = function(evt) {\n        if (_this._points[evt.pointerId]) {\n          _this._points[evt.pointerId].clientX = evt.clientX;\n          _this._points[evt.pointerId].clientY = evt.clientY;\n        }\n      };\n\n      _this.options.spot.addEventListener('pointerup', _this._pointup, false);\n      _this.options.spot.addEventListener('pointerdown', _this._pointdown, false);\n      _this.options.spot.addEventListener('pointermove', _this._pointmove, false);\n\n      if (fn !== undefined && Function.isFunction(fn)) {\n        fn();  \n      }\n    }, // end of StampSpot class\n\n    /**\n    * Initializes SnowDK with the clientId and their redirectUri\n    * @method init\n    * @param {string} args.clientId - The consumer's client id\n    * @param {string} [args.clientSecret] - The consumer's client secret. Not actually a secret since it's on the client but enables native apps to not have a consumer server. Also present in oAuth standards.\n    */\n    init = function(args) {\n      args = !!args ? args : {};\n\n      /**\n      * @prop {string} clientId     - The clientId for the consumer\n      */\n      clientId = !!args.clientId ? args.clientId : undefined;\n\n      /**\n      * @prop {string} clientSecret - The secret of the client. Obviously not secure but allows native-only apps to work on our API.\n      */\n      clientSecret = !!args.clientSecret ? args.clientSecret : undefined;\n\n      if (args.collectUsageData === false) {\n        keen = undefined;\n      }\n\n      // set the oAuth version\n      if (args.oauthVersion !== undefined || args.oauthVersion === 1) {\n        OAUTH_VERSION = 1;\n      } else if (args.oauthVersion === 2) {\n        OAUTH_VERION = 2;\n      }\n\n      return {makeSpot: makeSpot};\n    },\n\n    /**\n    * Creates a stamp spot and returns the ID for the stamp spot then used to bind to spot events using SpotOn.\n    * @param {object} args - The object for this document\n    * @param {DOMElement} args.spot - The element to listen to for the stamp presses.\n    * @param {method} args.success - The callback for a successful validation.\n    * @param {method} args.failure - The callback for a successful validation.\n    * @param {method} args.pre - Called before sending the stamp off to the SSS api. Return false to halt the process.\n    */\n    makeSpot = function(args, fn) {\n      if (args.spot === undefined) {\n        throw new Error('No spot element was passed in.');\n      } else if (args.success === undefined) {\n        throw new Error('No success handler was passed in.');\n      } else if (args.failure === undefined) {\n        throw new Error('No failure handler was passed in.');\n      }\n\n      var \n        spot = new StampSpot(args, fn),\n        spotId = spot.spotId;\n\n      // shoot off event to keen\n      if (keen !== undefined) {\n        keen.track('spot', {'type': 'init'});\n      }\n\n      stampSpots[spot.spotId] = spot;\n      return spot;\n    },\n\n    /**\n    * Common properties and methods across Stamp and StampSpot. \n    * @class StampType\n    */\n    StampType = function(){};\n\n  StampType.prototype = {\n    /**\n    * @prop {string} status\n    */\n    status: '', \n  }; // end of StampType prototype\n\n  /**\n  * @memberof StampSpot\n  * @namespace defaults\n  * @prop {element} defaults.elem  - Default element is the 'body'.\n  * @prop {string}  defaults.spotId        - Default spotId is a generated UUID.\n  */\n  util.inherit(StampSpot, StampType, {\n    defaults: {\n      'spot': document.getElementsByTagName('body')[0],\n      'spotId': util.uuid()\n    }\n  });\n\n  /**\n  * @namespace\n  * @memberof Stamp\n  * @prop {string} defaults.spotId - Default spotId is a generated UUID.\n  */\n  util.inherit(Stamp, StampType, {\n    defaults: {\n      'spotId': util.uuid()\n    }\n  });\n\n  return {init: init};\n});\n"
  ]
}